<html>
  <head>
    <meta charset="utf-8" />
    <script src="https://unpkg.com/three@0.137.4/build/three.min.js"></script>
    <script src="https://unpkg.com/three@0.137.4/examples/js/controls/OrbitControls.js"></script>
  </head>
<body>
 <script>
      // ページの読み込みを待つ
      window.addEventListener('DOMContentLoaded', init);

      let test;
      let testm;
      let test_;
   
      let scene;
   
      const arr = new Array();let stats;

	let grid;
	let controls;

		const wheels = [];

		function car(scene) {
			
			

			// materials
			const bodyMaterial = new THREE.MeshPhysicalMaterial( {
				color: 0xff0000, metalness: 1.0, roughness: 0.5, clearcoat: 1.0, clearcoatRoughness: 0.03, sheen: 0.5
			} );

			//鏡
			const detailsMaterial = new THREE.MeshStandardMaterial( {
				color: 0xffffff, metalness: 1.0, roughness: 0.5
			} );

			//窓
			const glassMaterial = new THREE.MeshPhysicalMaterial( {
				color: 0xffffff, metalness: 0.25, roughness: 0, transmission: 1.0, side: THREE.DoubleSide
			} );

			const mesh = new THREE.Mesh(
				new THREE.PlaneGeometry( 0.655 * 4, 1.3 * 4 ),
				detailsMaterial
			);
			scene.add( mesh );
			return;

			// Car

			const shadow = new THREE.TextureLoader().load( 'img/ferrari_ao.png' );

			const dracoLoader = new DRACOLoader();
			dracoLoader.setDecoderPath( 'js/libs/draco/gltf/' );

			const loader = new GLTFLoader();
			loader.setDRACOLoader( dracoLoader );

			loader.load( 'models/gltf/ferrari.glb', function ( gltf ) {

				const carModel = gltf.scene.children[ 0 ];

				carModel.getObjectByName( 'body' ).material = bodyMaterial;

				carModel.getObjectByName( 'rim_fl' ).material = detailsMaterial;
				carModel.getObjectByName( 'rim_fr' ).material = detailsMaterial;
				carModel.getObjectByName( 'rim_rr' ).material = detailsMaterial;
				carModel.getObjectByName( 'rim_rl' ).material = detailsMaterial;
				carModel.getObjectByName( 'trim' ).material = detailsMaterial;

				carModel.getObjectByName( 'glass' ).material = glassMaterial;

				wheels.push(
					carModel.getObjectByName( 'wheel_fl' ),
					carModel.getObjectByName( 'wheel_fr' ),
					carModel.getObjectByName( 'wheel_rl' ),
					carModel.getObjectByName( 'wheel_rr' )
				);

				// shadow
				const mesh = new THREE.Mesh(
					new THREE.PlaneGeometry( 0.655 * 4, 1.3 * 4 ),
					new THREE.MeshBasicMaterial( {
						map: shadow, blending: THREE.MultiplyBlending, toneMapped: false, transparent: true
					} )
				);
				mesh.rotation.x = - Math.PI / 2;
				mesh.renderOrder = 2;
				carModel.add( mesh );

				scene.add( carModel );

			} );

		}

      function init() {
        // サイズを指定
        const width = 800
        const height = 600;

        // レンダラーを作成
        var renderer = new THREE.WebGLRenderer();
        document.body.appendChild(renderer.domElement);
        renderer.setSize(width, height);
        // レンダラー：シャドウを有効にする
        renderer.shadowMap.enabled = true;

        // シーンを作成
        scene = new THREE.Scene();

        // カメラを作成
        const camera = new THREE.PerspectiveCamera(45, width / height);
        // カメラの初期座標を設定
        camera.position.set(0, 0, 5);

        // カメラコントローラーを作成
        const controls = new THREE.OrbitControls(camera, document.body); 
        
      // 平行光源(色、強さ）主光源
      var directionalLightM = new THREE.DirectionalLight(0xffffff, 0.3);
      directionalLightM.position.set(0, 10, -5);
      directionalLightM.castShadow = true; 
      //シーンに追加
      scene.add(directionalLightM);

      // 照明を作成SpotLight(色, 光の強さ, 距離, 照射角, ボケ具合, 減衰率)
      var light = new THREE.SpotLight(0xffffff, 1, 100, Math.PI / 20, 0.2);
      light.position.set(0,10, -15);
      light.target.position.set( 0, 5, -100 );
      // ライトに影を有効にする
      light.castShadow = true;
      //light.shadow.mapSize.width = 2048;
      //light.shadow.mapSize.height = 2048;
      //scene.add(light);

      // 平行光源(色、強さ）補助光源
      var directionalLightS = new THREE.DirectionalLight(0xffffff,0.3);
      directionalLightS.position.set(-1, -1, 1);
      // シーンに追加
      scene.add(directionalLightS);

        // helper
        const gridHelper = new THREE.GridHelper(2,10); // size, step
        scene.add(gridHelper);
        const axisHelper = new THREE.AxisHelper(5); //軸の長さ　X：赤、Y：緑、z：青
        scene.add(axisHelper);

        const textureLoader = new THREE.TextureLoader();

        const torus_size = 10000;
        const torus_width = 23;
        const torus_angle = torus_size / 10;
        const geometry = new THREE.TorusGeometry( torus_size, torus_width, 3, torus_angle);
        let x, y, z;
        let base = {
            x:geometry.attributes.normal.array[0],
            y:geometry.attributes.normal.array[1],
            z:geometry.attributes.normal.array[2]
        };
        const getSize = function(c){
          return Math.sqrt(c.x * c.x + c.y * c.y + c.z * c.z);
        }
        const inner = function(a, b){
          return a.x * b.x + a.y * b.y + a.z * b.z;
        }
        const cross = function(a, b){
          return {
            x : a.y * b.z - a.z * b.y,
            y : a.z * b.x - a.x * b.z,
            z : a.x * b.y - a.y * b.x,
          };
        }
        let tmp, tmp1, tmp2;
        for(let i = 0; i < 3 * torus_angle; i+= 3){
          tmp1 = {
              x:geometry.attributes.normal.array[i + 0],
              y:geometry.attributes.normal.array[i + 1],
              z:geometry.attributes.normal.array[i + 2]
          };
          tmp2 = {
              x:geometry.attributes.normal.array[i + 3],
              y:geometry.attributes.normal.array[i + 4],
              z:geometry.attributes.normal.array[i + 5]
          };

          tmp1.x -= geometry.attributes.normal.array[i + 3 * (torus_angle + 1) + 0];
          tmp1.y -= geometry.attributes.normal.array[i + 3 * (torus_angle + 1) + 1];
          tmp1.z -= geometry.attributes.normal.array[i + 3 * (torus_angle + 1) + 2];

          tmp2.x -= geometry.attributes.normal.array[i + 3 * (torus_angle + 1) + 0];
          tmp2.y -= geometry.attributes.normal.array[i + 3 * (torus_angle + 1) + 1];
          tmp2.z -= geometry.attributes.normal.array[i + 3 * (torus_angle + 1) + 2];

          tmp = cross(tmp1, tmp2);

          geometry.attributes.normal.array[i + 0] = tmp.x;
          geometry.attributes.normal.array[i + 1] = tmp.y;
          geometry.attributes.normal.array[i + 2] = tmp.z;
          geometry.attributes.normal.array[i + 3 * (torus_angle + 1) + 0] = tmp.x;
          geometry.attributes.normal.array[i + 3 * (torus_angle + 1) + 1] = tmp.y;
          geometry.attributes.normal.array[i + 3 * (torus_angle + 1) + 2] = tmp.z;
        }
        geometry.attributes.normal.array[3 * torus_angle + 0] = tmp.x;
        geometry.attributes.normal.array[3 * torus_angle + 1] = tmp.y;
        geometry.attributes.normal.array[3 * torus_angle + 2] = tmp.z;
        geometry.attributes.normal.array[3 * torus_angle + 3 * (torus_angle + 1) + 0] = tmp.x;
        geometry.attributes.normal.array[3 * torus_angle + 3 * (torus_angle + 1) + 1] = tmp.y;
        geometry.attributes.normal.array[3 * torus_angle + 3 * (torus_angle + 1) + 2] = tmp.z;
        geometry.attributes.normal.normalized = true;/**/
        const material = new THREE.MeshStandardMaterial();


        material.map = textureLoader.load("img/road.jpg");
        /*material.bumpMap = bump;
        material.bumpscale = 0.2;*/
        material.map.wrapS = THREE.RepeatWrapping;
        material.map.wrapT = THREE.RepeatWrapping;
        material.map.repeat.set(torus_size / 8, 3);/**/
        /*material.bumpMap.wrapS = THREE.RepeatWrapping;
        material.bumpMap.wrapT = THREE.RepeatWrapping;
        material.bumpMap.repeat.set(1, 10);*/
        const torus = new THREE.Mesh( geometry, material );
        torus.position.y -= torus_width / 2 + torus_size / 2 + 1;
        torus.position.x += torus_size * Math.sqrt(3) / 2 + 13;
        torus.rotation.x -= Math.PI / 2;
        torus.rotation.y += Math.PI / 6;
        //torus.receiveShadow = true; //影がつく
        scene.add( torus );
        arr.push(torus);

        scene.fog = new THREE.FogExp2(0x88888888, 0.0009765625);
        
        const torus_width2 = 20 * 3 / 2 - 7;
        const torus_angle2 = torus_size / 10;
        
        const geo = new THREE.TorusGeometry( torus_size, torus_width2, 6, torus_angle);
        const mat = new THREE.MeshStandardMaterial({side: THREE.DoubleSide, transparent: true, overdraw: true});
        mat.map = textureLoader.load("img/EOlMt9nPtM1zjeN1655908340_1655908353.png");
        mat.bumpMap = textureLoader.load("img/tester-bump.jpg");
        mat.bumpscale = 0.2;
        mat.map.wrapS = THREE.RepeatWrapping;
        mat.map.wrapT = THREE.RepeatWrapping;
        mat.map.repeat.set(torus_size / 16, 1);
        mat.bumpMap.wrapS = THREE.RepeatWrapping;
        mat.bumpMap.wrapT = THREE.RepeatWrapping;
        mat.bumpMap.repeat.set(torus_size / 16, 1);
        
        const tor = new THREE.Mesh(geo, mat);
        tor.position.y -= - torus_width2 / 2 + torus_size / 2 + 1;
        tor.position.x += torus_size * Math.sqrt(3) / 2 + 13;
        tor.rotation.x -= Math.PI / 2;
        tor.rotation.y += Math.PI / 6;
        scene.add(tor);
        arr.push(tor);


        const skySize = 500;
        const skyGeometry = new THREE.CylinderGeometry( skySize, skySize, 5000, 32 );
        const skyMaterial = new THREE.MeshBasicMaterial({side: THREE.BackSide});
        skyMaterial.map = textureLoader.load("img/sky.jpg");
        skyMaterial.map.wrapS = THREE.MirroredRepeatWrapping;
        skyMaterial.map.wrapT = THREE.MirroredRepeatWrapping;
        skyMaterial.map.repeat.set(2, 2);
        const mats = [
        	skyMaterial,
        	new THREE.MeshBasicMaterial({color: 0, transparent: true, opacity: 0}),
        	new THREE.MeshBasicMaterial({color: 0, transparent: true, opacity: 0})
        ];
        const sky = new THREE.Mesh(skyGeometry, new THREE.MeshFaceMaterial(mats));

        sky.rotation.x += Math.PI / 2;
        
        const Sky = new THREE.Group();
        Sky.add(sky);
        Sky.position.x += 20;
        Sky.position.y += skySize / 2;
        Sky.rotation.z -= 0.5;
        Sky.rotation.x -= 0.5;
        
        scene.add(Sky);
        arr.push(sky);/**/
        
        /*light = new THREE.SpotLight(0xFFFFFF, 1, 60, Math.PI / 4, 10, 0.5);
        light.position.set(-4, 23, 0);
        light.target.position.set(5, 0, 0);
        light.target.updateMatrixWorld();
		scene.add(light);
		arr.push(light);*/
		
		const box = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1, 1), new THREE.MeshBasicMaterial({color: 0xffffff}));
		//scene.add(box);
		//arr.push(box);
		
		
		light = new THREE.AmbientLight(0xFFFFFF, 1.0);
		//scene.add(light);
		

	    scene.background = new THREE.Color( 0xffffff );
	    
	    
	    car(scene);
              
        
        update(); //繰り返しイベントへ 

        // 毎フレーム時に実行されるループイベントです
        function update() {
          // レンダリング
          renderer.render(scene, camera);
          requestAnimationFrame(update);
          torus.rotation.z -= 0.05;
          tor.rotation.z -= 0.05;
          sky.rotation.y += 0.0005;
          //return;

          
          
          let d = sky.rotation.y;
          
          
          scene.fog.density = 0.0009765625 + 0.0068359375 * Math.sin(d / 2) * Math.sin(d / 2);
          
        }
      }
    </script>
</body>
</html>