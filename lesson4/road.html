<html>
  <head>
    <meta charset="utf-8" />
    <title>バンプマップ、テクスチャとジオメトリの対応</title>
    <script src="https://unpkg.com/three@0.137.4/build/three.min.js"></script>
    <script src="https://unpkg.com/three@0.137.4/examples/js/controls/OrbitControls.js"></script>
  </head>
<body>
 <script>
      // ページの読み込みを待つ
      window.addEventListener('DOMContentLoaded', init);

      function createpillar6(l, t, material){
        const pillar = new THREE.Group();
        const boxGeometry = new THREE.BoxGeometry(l, t, l*Math.sqrt(3));

        let box = new THREE.Mesh(boxGeometry, material);
        box.castShadow = true;
        box.receiveShadow = true;
        pillar.add(box);

        box = new THREE.Mesh(boxGeometry, material);
        box.rotation.y += Math.PI / 3;
        box.castShadow = true;
        box.receiveShadow = true;
        pillar.add(box);

        box = new THREE.Mesh(boxGeometry, material);
        box.rotation.y -= Math.PI / 3;
        box.castShadow = true;
        box.receiveShadow = true;
        pillar.add(box);

        return pillar;
      }

      function createStreetLight(){
        const sqrt3 = Math.sqrt(3);
        const phongMat = new THREE.MeshPhongMaterial({color: 0x444444});
        const lambertMat = new THREE.MeshLambertMaterial({color: 0x444444});

        const pedestal = new THREE.Group();

        var basis = createpillar6(1, 0.1, phongMat);
        pedestal.rotation.y += Math.PI / 6;
        pedestal.add(basis);

        basis = new THREE.Mesh(                                     
            new THREE.CylinderGeometry(sqrt3 / 2 - 0.4,sqrt3 / 2 - 0.1,1,50),
            phongMat
        );
        basis.position.y += 0.5  + 0.05;
        basis.castShadow = true;
        basis.receiveShadow = true;
        pedestal.add(basis);

        const pillar = new THREE.Group();
        const post = new THREE.Mesh(                                     
            new THREE.CylinderGeometry(sqrt3 / 2 - 0.65,sqrt3 / 2 - 0.55, 7,50),
            phongMat
        );
        post.position.y += 3.5 + 1  + 0.05;
        post.castShadow = true;
        post.receiveShadow = true;
        pillar.add(post);

        var ornament;

        const head = new THREE.Group();
        ornament = new THREE.Mesh(                                     
            new THREE.CylinderGeometry(sqrt3 / 2 - 0.55,sqrt3 / 2 - 0.55, 0.25,50),
            phongMat
        );
        ornament.position.y +=  7 + 1  + 0.05 + 0.125 - 0.25;
        ornament.castShadow = true;
        ornament.receiveShadow = true;
        head.add(ornament);

        ornament = createpillar6(sqrt3 / 2 - 0.45, 0.1, phongMat);
        ornament.position.y +=  7 + 1  + 0.05 + 0.05;
        head.add(ornament);

        ornament = createpillar6(sqrt3 / 2 - 0.40, 0.1, phongMat);
        ornament.position.y +=  7 + 1  + 0.05 + 0.1 + 0.05;
        head.add(ornament);

        ornament = createpillar6(sqrt3 / 2 - 0.35, 0.1, phongMat);
        ornament.position.y +=  7 + 1  + 0.05 + 0.1 + 0.1 + 0.05;
        head.add(ornament);

        ornament = new THREE.Mesh(                                     
            new THREE.CylinderGeometry(sqrt3 / 2 - 0.25,sqrt3 / 2 - 0.35, 0.05,6),
            phongMat
        );
        ornament.position.y +=  7 + 1  + 0.05 + 0.1 + 0.1 + 0.1 + 0.025;
        ornament.rotation.y += Math.PI / 6;
        ornament.castShadow = true;
        ornament.receiveShadow = true;
        head.add(ornament);

        ornament = createpillar6(sqrt3 / 2 - 0.25, 0.1, phongMat);
        ornament.position.y +=  7 + 1  + 0.05 + 0.1 + 0.1 + 0.1 + 0.05 + 0.05;
        head.add(ornament);

        const k = Math.atan(0.075 * sqrt3);
        const l = Math.atan(0.075);

        ornament = createpillar6(0.05, 1, phongMat);
        ornament.position.y +=  7 + 1  + 0.05 + 0.1 + 0.1 + 0.1 + 0.025 + 0.6;
        ornament.position.x +=  (sqrt3 / 2 - 0.25 - 0.05) / 2 + 0.55*Math.sin(k) - 0.0352;
        ornament.position.z +=  sqrt3 * (sqrt3 / 2 - 0.25 - 0.05) / 2 + 0.55*Math.sin(l) + 0.0215;
        ornament.rotation.x += k;
        ornament.rotation.z -= l;
        head.add(ornament);

        ornament = createpillar6(0.05, 1, phongMat);
        ornament.position.y +=  7 + 1  + 0.05 + 0.1 + 0.1 + 0.1 + 0.025 + 0.6;
        ornament.position.x -=  (sqrt3 / 2 - 0.25 - 0.05) / 2 + 0.55*Math.sin(k) - 0.0351;
        ornament.position.z +=  sqrt3 * (sqrt3 / 2 - 0.25 - 0.05) / 2 + 0.55*Math.sin(l) + 0.022;
        ornament.rotation.x += k;
        ornament.rotation.z += l;
        head.add(ornament);

        ornament = createpillar6(0.05, 1, phongMat);
        ornament.position.y +=  7 + 1  + 0.05 + 0.1 + 0.1 + 0.1 + 0.025 + 0.6;
        ornament.position.x +=  (sqrt3 / 2 - 0.25 - 0.05) / 2 + 0.55*Math.sin(k) - 0.0351;
        ornament.position.z -=  sqrt3 * (sqrt3 / 2 - 0.25 - 0.05) / 2 + 0.55*Math.sin(l) + 0.022;
        ornament.rotation.x -= k;
        ornament.rotation.z -= l;
        head.add(ornament);

        ornament = createpillar6(0.05, 1, phongMat);
        ornament.position.y +=  7 + 1  + 0.05 + 0.1 + 0.1 + 0.1 + 0.025 + 0.6;
        ornament.position.x -=  (sqrt3 / 2 - 0.25 - 0.05) / 2 + 0.55*Math.sin(k) - 0.0351;
        ornament.position.z -=  sqrt3 * (sqrt3 / 2 - 0.25 - 0.05) / 2 + 0.55*Math.sin(l) + 0.022;
        ornament.rotation.x -= k;
        ornament.rotation.z += l;
        head.add(ornament);

        const m = Math.atan(0.15);

        ornament = createpillar6(0.05, 1, phongMat);
        ornament.position.y +=  7 + 1  + 0.05 + 0.1 + 0.1 + 0.1 + 0.025 + 0.6;
        ornament.position.x +=  sqrt3 / 2 - 0.25 - 0.05 + 0.55*Math.sin(m) - 0.0105;
        ornament.rotation.z -= m;
        head.add(ornament);

        ornament = createpillar6(0.05, 1, phongMat);
        ornament.position.y +=  7 + 1  + 0.05 + 0.1 + 0.1 + 0.1 + 0.025 + 0.6;
        ornament.position.x -=  sqrt3 / 2 - 0.25 - 0.05 + 0.55*Math.sin(m) - 0.0105;
        ornament.rotation.z += m;
        head.add(ornament);

        ornament = createpillar6(sqrt3 / 2 - 0.1, 0.1, phongMat);
        ornament.position.y +=  7 + 1  + 0.05 + 0.1 + 0.1 + 0.1 + 0.1 + 0.05 + 1;
        head.add(ornament);

        ornament = new THREE.Mesh(                                     
            new THREE.CylinderGeometry(sqrt3 / 2 - 0.15,sqrt3 / 2 - 0.1, 0.05,6),
            phongMat
        );
        ornament.castShadow = true;
        ornament.receiveShadow = true;
        ornament.position.y +=  7 + 1  + 0.05 + 0.1 + 0.1 + 0.1 + 0.1 + 0.05 + 1 + 0.075;
        ornament.rotation.y += Math.PI / 6;
        head.add(ornament);

        const streetLight = new THREE.Group();

        const light = new THREE.PointLight(0xFFFFFF, 1, 50, 1.0);
        light.castShadow = true;
        light.position.y +=  7 + 1  + 0.05 + 0.1 + 0.1 + 0.1 + 0.1 + 0.05 + 0.9;

        streetLight.add(pedestal);
        streetLight.add(pillar);
        streetLight.add(head);
        streetLight.add(light);

        var sample = createpillar6(sqrt3 / 2 - 0.1, 0.1, phongMat);
        sample.position.y +=  7 + 1  + 0.05 + 0.1 + 0.1 + 0.1 + 0.1 + 0.05 + 1;
        streetLight.add(sample);

        return streetLight;
      }

      function init() {
        // サイズを指定
        const width = 800
        const height = 600;

        // レンダラーを作成
        var renderer = new THREE.WebGLRenderer();
        document.body.appendChild(renderer.domElement);
        renderer.setSize(width, height);
        renderer.shadowMap.enabled = true;

        // シーンを作成
        const scene = new THREE.Scene();

        // カメラを作成
        const camera = new THREE.PerspectiveCamera(45, width / height);
        // カメラの初期座標を設定
        camera.position.set(0, 0, 100);

        // カメラコントローラーを作成
        const controls = new THREE.OrbitControls(camera, document.body); 
        
        // 平行光源1
        var directionalLight1 = new THREE.DirectionalLight(0xffffff);
        directionalLight1.position.set(10, 10, 10);
        // シーンに追加
        //scene.add(directionalLight1);
        // 平行光源2
        var directionalLight2 = new THREE.DirectionalLight(0x888888);
        directionalLight2.position.set(-10, -10, 10);
        // シーンに追加
        //scene.add(directionalLight2);

        // helper
        const gridHelper = new THREE.GridHelper(100,25); // size, step
        scene.add(gridHelper);

        const axisHelper = new THREE.AxisHelper(100,25);
        scene.add(axisHelper);

        // 平面を作成
        var planeGeometry = new THREE.PlaneGeometry(22,150);
        //var planeMaterial = new THREE.MeshBasicMaterial({color: 0x00ff00});
        var planeMaterial = new THREE.MeshPhongMaterial();
        var stoneTxt = textureLoader.load("stone.jpg");
        var bump = textureLoader.load("stone-bump.jpg");
        planeMaterial.map = stoneTxt;
        planeMaterial.bumpMap = bump;
        planeMaterial.bumpscale = 0.2;
        planeMaterial.map.wrapS = THREE.RepeatWrapping;
        planeMaterial.map.wrapT = THREE.RepeatWrapping;

        scene.add(plane);



        /*const poll = new THREE.Mesh(                                     
            new THREE.CylinderGeometry(5,5,40,50),                         
            new THREE.MeshPhongMaterial({color: 0x00FF7F})
        );

        scene.add(poll);*/

        const streetLight = new Array();
        for(let i = 0; i < 7; i++){
            let obj = createStreetLight();
            obj.position.x = 10;
            obj.position.z = -20 * i + 3 * 20;
            streetLight.push(obj);

            obj = createStreetLight();
            obj.position.x = -10;
            obj.position.z = -10 * i;
            //streetLight.push(obj);
        }

        for(let i = 0; i < streetLight.length; i++){
            scene.add(streetLight[i]);
        }

        /*scene.add(new THREE.Mesh(                                     
            new THREE.CylinderGeometry(10,10,10,6),                         
            new THREE.MeshPhongMaterial({color: 0x00FF7F})
        ));*/
        
/*
        // テクスチャー読み込み
        var textureLoader = new THREE.TextureLoader();  
        var texture = textureLoader.load("cit.png");
        var mat = new THREE.MeshPhongMaterial();
        mat.map = texture;
        
        var stoneTxt = textureLoader.load("stone.jpg");
        var stoneMat = new THREE.MeshPhongMaterial();
        mat.map = stoneTxt;
        
        var bump = textureLoader.load("stone-bump.jpg");
        mat.bumpMap = bump;
        mat.bumpscale = 0.2;
        
        //6面分のテクスチャー読み込み
        var materials = [
          mat,mat,mat,mat,
          new THREE.MeshLambertMaterial({map:THREE.ImageUtils.loadTexture("img/img5.png")}),
          new THREE.MeshLambertMaterial({map:THREE.ImageUtils.loadTexture("img/img6.png")}),
        ];
 
        var material = new THREE.MeshFaceMaterial(materials); // マテリアルをセット

        // 箱を作成
        var geometry1 = new THREE.BoxGeometry(0.8, 0.8, 0.8);
        //var material = new THREE.MeshPhongMaterial({ color: 0xffffff });
        //var box = new THREE.Mesh(geometry, material);
        var box = new THREE.Mesh(geometry1, material);
        box.position.set(-1.5,0,0); //位置を指定
        scene.add(box);   // シーンに追加

        // 球を作成
        var geometry2 = new THREE.SphereGeometry(0.5, 32, 32 ); ;
        var Sphere = new THREE.Mesh(geometry2, mat);
        Sphere.position.set(0,0,0);
        scene.add(Sphere);

        //6面分のテクスチャー読み込み
        var Cmaterials = [
          mat,mat,
          new THREE.MeshLambertMaterial({map:THREE.ImageUtils.loadTexture("img/img6.png")}),
        ];
 
        var Cmaterial = new THREE.MeshFaceMaterial(Cmaterials); // マテリアルをセット
 
        // 円柱を作成
        var geometry3 = new THREE.CylinderGeometry( 0.2, 0.5, 0.5, 20, 4 );
        var Cylinder = new THREE.Mesh(geometry3, Cmaterial);
        Cylinder.position.set(1.5,0,0);
        scene.add(Cylinder);
        
        
        var geometry4 = new THREE.TorusGeometry( 4, 1, 16, 100);
        var Torus = new THREE.Mesh(geometry4, mat);
        Torus.position.set(0,1,0);
        scene.add(Torus);
*/

        update();

        // 毎フレーム時に実行されるループイベントです
        function update() {
          // レンダリング
          renderer.render(scene, camera);
          requestAnimationFrame(update);
        }
      }
    </script>
</body>
</html>
